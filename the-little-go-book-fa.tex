\documentclass{book}
\usepackage[a4paper,includeheadfoot,margin=2.54cm]{geometry}
\providecommand{\tightlist}{
\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\usepackage{fontspec}
\usepackage{listings}
\usepackage[stable]{footmisc}
\lstdefinelanguage{Go}{
	keywords = {run, build, new, go, true, false, func, return, nil, switch, select, var, if, range, for, else, case, break, int, string, bool, make, len, append},
	keywordstyle = \color{SkyBlue}\bfseries,
	ndkeywords = {package, import, struct, interface, main},
	ndkeywordstyle = \color{Aluminium6}\bfseries,
	identifierstyle = \color{Black},
	sensitive = false,
	comment = [l]{//},
	morecomment = [s]{/*}{*/},
	commentstyle = \color{Plum}\ttfamily,
	stringstyle = \color{Green}\ttfamily,
	morestring = [b]',
	morestring = [b]`,
	morestring = [b]"
}

\lstset{
	language = Go,
	backgroundcolor = \color{Aluminium1},
	extendedchars = true,
	basicstyle = \normalsize\ttfamily,
	showstringspaces = false,
	showspaces = false,
	tabsize = 1,
	breaklines = true,
	showtabs = false
}
%% Set line spacing
\usepackage{setspace}
\setstretch{1.2}
%% Disable paragraph indentation
\usepackage{parskip}
%% Start sections from new page
%\let\stdsection\section
%\renewcommand\section{\newpage\stdsection}
% Colors
\usepackage{xcolor}
%% Tango color scheme
\definecolor{SkyBlue}{HTML}{3465A4}
\definecolor{DarkSkyBlue}{HTML}{204A87}
\definecolor{Plum}{HTML}{75507B}
\definecolor{Green}{HTML}{4F8124}
\definecolor{Aluminium1}{HTML}{F8F8F8}
\definecolor{Aluminium6}{HTML}{2e3436}
\definecolor{Black}{HTML}{000000}
% Listings
\usepackage{listings}

\usepackage{graphicx}

\usepackage{enumerate}
%% Disable section numbers
\setcounter{secnumdepth}{0}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=cyan,
}
\usepackage{graphicx}
\usepackage{xepersian}
\settextfont{XB Zar}
\usepackage{perpage} %the perpage package
\MakePerPage{footnote} %the perpage package command
\begin{document}
\thispagestyle{empty}
\begin{titlepage}
 \vspace*{1cm}
 \includegraphics{title}
 
 {\huge\raggedleft کتاب کوچک Go\par}
 \noindent\hrulefill\par
 {\LARGE\raggedright کارل سگوین\par}
 \vfill
 {\small\raggedright کیارش بختیار\par}
 \setcounter{page}{0}
\end{titlepage}
\tableofcontents
\chapter{در باره این کتاب }%فصل اول
\newpage
\section{مجوز}
کتاب کوچک \lr{Go} تحت مجوز بین‌المللی   \lr{Attribution-NonCommercial-ShareAlike} نسخه ۴٫۰ منتشر شده‌است. نیازی به پرداخت هزینه برای این کتاب نیست. شما در کپی، توزیع، اصلاح یا نمایش کتاب آزاد هستید. با این حال، تقاضا می‌کنم که همیشه کتاب را به من نسبت دهید (کارل سگوین) و از آن برای اهداف تجاری استفاده نکنید.
متن کامل مجوز را می‌توانید در نشانی زیر مشاهده کنید:

\begin{latin}
\url{https://creativecommons.org/licenses/by-nc-sa/4.0/}
\end{latin}

\newpage
\section{آخرین نسخه}

منبع آخرین نسخه در نشانی \url{https://github.com/karlseguin/the-little-go-book} در دسترس قرار دارد.
\newpage
\section{یاداداشت مترجم}
شاید اغراق نباشد که عنوان کنم انگیزه از ترجمه این کتاب بیشتر خودخواهانه بوده‌است. از آن‌جا که به زبان برنامه نویسی \lr{Go} علاقه‌مند شدم و قصد یادگیری آن‌را داشتم، در گشت و گذار اینترنتی هنگامی که به دنبال منابع بودم  با کتاب پیش رو آشنا شدم. همانگونه که در بخش مجوز مشاهده کردید، انتشار و ترجمه آن آزاد است. در نتیجه برآن شدم تا روش یادگیری حین ترجمه را تجربه کنم. از طرفی تصمیم گرفتم در نگارش کتاب نرم‌افزار قدرتمند حروف‌چینی لاتِکْ (\lr{\LaTeX})را با استفاده از بسته زی‌پرشین  (\lr{\XePersian}) به‌کار گیرم که جذابیت خاص خود را دارد. در نهایت برای کنترل منبعِ متن ترجمه، از نرم‌افزار \lr{git} و همسان‌سازی آن با \lr{github} در آدرس ذیل استفاده نمودم.
\begin{latin}
	\url{https://github.com/Kiarashbakhtiar/the-little-go-book-fa}
\end{latin}
\
\begin{flushleft}
	کیارش بختیار، پاییز ۱۳۹۹
	
\end{flushleft}


\chapter{ مقدمه }%فصل دوم
همواره نوع رابطه‌ام در یادگیری زبان‌های جدید عشق و نفرت است. از یک سو، زبان‌ها برای کاری که ما می‌کنیم بسیار اساسی هستند، به طوری که حتی تغییرات کوچک می‌توانند تأثیر قابل ملاحظه‌ای داشته باشند. در لحظه‌ای خاص کلیک کردن می‌تواند تأثیر ماندگاری بر نحوه برنامه نویسی شما داشته باشد و می تواند انتظارات شما را از زبان‌های دیگر تعیین کند. از جنبه منفی، طراحی زبان به طور نسبی افزایشی است. یادگیری کلمات کلیدی جدید، نوع سامانه، روش کدگذاری و همچنین کتابخانه‌ها، جوامع و پارادایم‌های جدید کار بزرگی است که توجیه آن دشوار به نظر می‌رسد. در مقایسه با هر چیز دیگری که باید یاد بگیریم، زبان‌های جدید اغلب احساس سرمایه گذاری محدود در زمان را برای ما همره دارند. 

با این اوصاف ما باید رو به جلو جرکت کنیم. خواست باید این باشد که گام‌های اساسی برداریم، زیراکه زبان‌ها پایه و اساس کار ما هستند. اگرچه این تغییرات غالباً افزایشی است، اما دامنه گسترده‌ای دارند و بر بهره‌وری، خوانایی، عملکرد، آزمون، مدیریت وابستگی، مدیریت خطا، مستندات، پروفایل، جوامع، کتابخانه‌های استاندارد و غیره تأثیر گذارند.

در اینجا یک سؤال اساسی مطرح می‌شود: \textbf{چرا  \lr{Go}؟} برای من دو دلیل قانع کننده وجود دارد. نخست این است که
یک زبان نسبتاً ساده با یک کتابخانه استاندارد نسبتاً ساده. از بسیاری جهات، ماهیت افزایشی \lr{Go} باعث ساده نمودن برخی از پیچیدگی‌هایی است که طی دو دهه گذشته شاهد اضافه شدن آن به زبان‌ها بوده ایم. دلیل دیگر این است که برای بسیاری از توسعه‌دهندگان ، زرادخانه آن‌ها را تکمیل می‌کند. 

زبان  \lr{Go} به عنوان یک زبان سیستم ساخته شده است (به عنوان مثال، برای توسعه سیستم‌عامل‌ها و درایور دستگاه‌ها) بنابراین هدف آن، توسعه دهندگان \lr{C} و  \lr{C++} است. طبق گفته تیم \lr{Go}-این مطمئناً در مورد من صادق است- توسعه‌دهندگان برنامه‌ها غیر از  توسعه‌دهندگان سیستم، به استفاده‌کنندگان اصلی \lr{Go} تبدیل شده‌اند. چرا؟ من نمی‌توانم برای توسعه‌دهندگان سیستم مقتدرانه صحبت کنم، اما برای آن دسته از ما که وب‌سایت‌ها، سرویس‌ها، برنامه‌های رومیزی و موارد مشابه ایجاد می‌کنیم، تا حدی به نیاز آشکاری وجود دارد به یک کلاس از سیستم‌هایی که در جایی بین برنامه‌های سطح پایین سیستم و برنامه های سطح بالاتر قرار دارند.

شاید این یک پیام رسان، ذخیره سازی، تجزیه و تحلیل داده های سنگین محاسباتی، رابط خط فرمان، ثبت رخداد‌ها یا سامانه نظارتی باشد. من نمی‌دانم چه برچسبی به آن بدهم، اما در طول کار حرفه‌ای من، به دلیل اینکه سیستم‌ها همچنان از لحاظ پیچیدگی رشد می‌کنند و نیاز به همزمانی و اندازه آن  نیز به همین صورت رشد می‌کند، آشکارا نیاز به سیستم‌های سفارشی از نوع زیرساخت وجود دارد. شما می توانید چنین سیستم‌هایی را با \lr{Ruby} یا \lr{Python} یا چیز دیگری بسازید (البته بسیاری از افراد این کار را می‌کنند)، اما این نوع سیستم‌ها می‌توانند از یک سیستم سفت و محکم با عملکرد بیشتر بهره‌مند شوند. به طور مشابه، شما می توانید از \lr{Go} برای ساختن وب سایت استفاده کنید (البته بسیاری از مردم این کار را می کنند)، اما من همچنان ترجیح می‌دهم برای انجام این کار را از  \lr{Node} یا \lr{Rubby} برای چنین سیستم‌هایی استفاده نمایم.

سطح دیگری وجود دارد که \lr{Go} برتری دارد. به عنوان مثال، هنگام اجرای یک برنامه \lr{Go} که کامپایل شده است، هیچ وابستگی وجود ندارد. دیگر لازم نیست که نگران باشید کاربران شما \lr{Ruby} یا \lr{JVM} را نصب کرده اند و اگر چنین است، چه نسخه‌ای نصب است. به همین دلیل، \lr{Go} به عنوان زبانی برای برنامه‌های رابط خط فرمان و سایر انواع برنامه های کمکی که برای توزیع نیاز دارید (به عنوان مثال، یک ثبت کننده ورود به سیستم) محبوبیت بیشتری پیدا می‌کند.

به بیان ساده، یادگیری \lr{Go} استفاده کارآمد از وقت شماست. شما مجبور نیستید ساعت‌های طولانی را برای یادگیری یا حتی تسلط بر \lr{Go} صرف کنید، و در نهایت به یک نتیجه عملی از تلاش خود خواهید رسید.
\newpage
\section{یادداشت نویسنده}
به چند دلیل از نوشتن این کتاب دریغ کرده‌بودم. اولین مورد این است که مستندات خود \lr{Go}، به ویژه
 \lr{\href{https://golang.org/doc/effective_go.html}{Effective Go}}
 قابل اطمینان  هستند.
 
 مورد دیگر ناراحتی من از نوشتن کتابی درباره یک زبان است. وقتی کتاب \lr{The Little MongoDB }را نوشتم، از این تصور که اکثر خوانندگان، اصول پایگاه‌داده رابطه‌ای و مدل‌سازی را بدانند، مطمئن بودم.  با کتاب \lr{Little Redis Book}، می توانید با ذخیره‌سازی داده‌ها به صورت کلید-مقدار  آشنا شوید و از  آن بهره ببرید. 
  
 آنگونه که در مورد بندها و فصول پیش رو فکر می‌کنم، می‌دانم که نمی توانم همان فرضیات را بیان کنم. چه مدت زمان صرف صحبت در مورد رابط‌ها می‌کنید؟ تا بدانید برای برخی از افراد، این مفهوم جدید خواهد بود، در حالی که دیگران به بیش از آنچه رابط \lr{Go}\href دارد، نیاز نخواهند داشت. در نهایت، اگر به من بگویید که کدام  قسمت‌ها خیلی کم‌عمق و یا بعضی دیگر خیلی دقیق هستند. باعث راحتی من می‌شود. این را به عنوان هزینه کتاب در نظر بگیرید.
\newpage



\chapter{ شروع }‌ % فصل سوم
اگر می‌خواهید کمی با \lr{Go} بازی کنید، باید \lr{\href{https://play.golang.org/}{Go Playground} } را بررسی کنید که به شما این امکان را می‌دهد بدون نیاز به نصب هر چیزی، کد را به صورت آنلاین اجرا کنید. این همچنین متداول‌ترین روش برای به اشتراک گذاشتن کد \lr{Go} در هنگام جستجوی کمک در \href{https://groups.google.com/forum/#!forum/golang-nuts}{انجمن‌ها} و مکانهایی مانند \lr{StackOverflow} است.

نصب \lr{Go} ساده است. می توانید آن را از مبدا نصب کنید، اما پیشنهاد می‌کنم از یکی از باینری‌های از پیش کامپایل شده استفاده کنید. وقتی به \href{https://golang.org/dl/}{صفحه بارگیری} می‌روید ، فایل نصبی مربوط به سیستم‌عامل‌های مختلف را مشاهده خواهیدکرد.  اجازه دهید  از این موارد اجتناب کنیم و بیاموزیم که چگونه \lr{Go} را خودمان برپا کنیم. همانطور که خواهید دید، کار سختی نیست. به استثنای مثالهای ساده، \lr{Go} طوری طراحی شده است که کد شما در داخل یک فضای‌کاری باشد. فضای‌کاری یک پوشه است که از زیر پوشه‌های \verb*|pkg|، \verb*|src|و \verb*|bin| تشکیل شده است. ممکن است وسوسه شوید که \lr{Go} را مجبور کنید از روش شما پیروی کند، هرگز این کار را نکنید.
به طور معمول، من پروژه‌های خود را در داخل \verb|~/doc|،  قرار می‌دهم. برای مثال \verb*|~doc/blog/| شامل فایل‌های بلاگ من است. برای \lr{Go} فضای کاری من \verb*|~/code/go| است و وبلاگ \lr{Go-powered} در  \verb*|~/code/go/src/blog| قرار گرفته است.

به طور خلاصه، هرکجا قصد دارید پروژه‌های خود را قرار دهید، یک پوشه \verb*|go| با یک زیر پوشه \verb*|src| ایجاد کنید.

 \newpage
  \section{سیستم‌عامل OSX / Linux }
  فایل
  \LRE{ \verb*|tar.gz| }
  را بر اساس پلتفرم خودتان بارگیری کنید.
  در \lr{OSX}، به احتمال زیاد علاقه‌مند هستید از
  \verb|go#.#.#.darwin-amd64-|
  \
  \verb*|osx10.8.tar.gz|
  استفاده نمایید که در آن \verb*|#.#.#| آخرین نسخه \lr{Go} است.
  
  با استفاده از دستور  ذیل
  \begin{latin}
  	\begin{lstlisting}[language=bash]
  		tar -C /usr/local -xzf go#.#.#.darwin-amd64-osx10.8.tar.gz
  	\end{lstlisting}
  \end{latin}
  
  فایل را در مسیر
  \verb*|/usr/local|
  از حالت فشرده خارج کنید.
  
  دو متغیر محیطی ذیل را تنظیم کنید:
\begin{enumerate}
	\item
	عبارت \verb*|GOPATH| به محیط کاری شما اشاره می‌کند. مثلاً برای من مسیر \verb*|$HOME/code/go| است.
	\item
	
 باید باینری \lr{Go} را به \verb*|PATH| خود اضافه کنیم.
	
\end{enumerate}
با استفاده از دستورات ذیل در \lr{shell} می‌توان این کار را انجام داد:
\begin{latin}
	\begin{lstlisting}[language=bash]
		echo 'export GOPATH=$HOME/code/go' >> $HOME/.profile
		echo 'export PATH=$PATH:/usr/local/go/bin' >> $HOME/.profile
	\end{lstlisting}
\end{latin}
به منظور اعمال تغیرات می‌توانید پوسته خود را بسته و دوباره باز کنید، یا می‌توانید دستور \verb*|source $HOME/.profile| را اجرا کنید.
دستور \LRE{\verb*|go version|}  را تایپ کنید تا خروجی مانند \LRE{ \verb*|go version go1.3.3 darwin/amd64|} نمایش داده شود.
\newpage
\section{سیستم‌عامل Windows}
آخرین فایل  \verb*|zip| را بارگیری کنید. اگر در یک سیستم ۶۴ بیتی هستید، به احتمال زیاد علاقه‌مند هستید از
\LRE{\verb|go#.#.#.darwin-amd64-|} \LRE{\verb*|windows-amd64.zip|}
استفاده نمایید که در آن \verb*|#.#.#| آخرین نسخه \lr{Go} است.

آن را در محلی که انتخاب کرده اید از حالت فشرده خارج کنید. پوشه \verb*|c:\Go| انتخاب مناسبی خواهد بود.

دو متغیر محیطی ذیل را تنظیم کنید:
\begin{enumerate}
	\item
	عبارت \verb*|GOPATH| به محیط کاری شما اشاره می‌کند. برای مثال می‌تواند مسیر \verb*|c:\users\goku\work\go| باشد.
	\item
	
	مسیر  \verb*|c:\Go\bin| را به \verb*|PATH|  سیستم‌عامل خود اضافه کنید.
\end{enumerate}
	
متغیرهای محیطی را می‌توان از طریق گزینه \LRE{ \verb*|Environment Variables|} در برگه \verb*|Advanced| صفحه \verb*|System| در \lr{Control Panel }تنظیم کرد. برخی از نسخه‌های ویندوز این کنترل را از طریق گزینه \LRE{\verb*|Advanced System Settings|}  موجود در \verb*|System| که در \lr{Control Panel } قرار دارد، ارائه می‌دهند.
یک \lr{command prompt} باز کنید و عبارت \LRE{\verb*|go version|} را تایپ کنید. امیدوارم خروجی که دریافت می‌کنید مانند \LRE{\verb*|go version go1.3.3 windows/amd64|} باشد.


\chapter{ مبانی }
\lr{Go}
 یک زبان کامپایلری، نوع  داده استاتیک و با یک نحو شبیه \lr{C} و دارای زباله‌روب است. معنی آن چیست؟
\newpage
\section{کامپایل}
کامپایل فرآیند ترجمه به زبان سطح پایین‌تر یا اسمبلی، برای کدی است که می‌نویسید (همانطور که در مورد \lr{Go} وجود دارد)، که در برخی از زبان های میانی دیگر (مانند جاوا و \lr{C\#}) وجود دارد.

کار با زبانهای کامپایل شده می‌تواند ناخوشایند باشد زیرا کامپایل کند است. اگر مجبور باشید چند دقیقه یا چند ساعت در انتظار کامپایل کد باشید، تکرار سریع آن دشوار است. سرعت کامپایل یکی از اهداف اصلی طراحی Go است. این برای افرادی که در پروژه های بزرگ کار می‌کنند  خبر خوبی است و همچنین کسانی که به چرخه بازخورد سریع ارائه شده توسط زبان‌های تفسیر شده عادت دارند.

زبانهای کامپایل شده معمولاً سریعتر اجرا می شوند و قابلیت اجرایی را می‌توان بدون وابستگی‌های اضافی اجرا کرد. این برای زبانهایی مانند \lr{C}، \lr{C++} و \lr{Go} که مستقیماً به اسمبلی کامپایل می شوند صدق می‌کند.
\newpage
\section{ایستایی نوع داده}
نوع ثابت بودن به معنای این است که متغیرها باید از نوع مشخص باشند (\LRE{ []byte ،int ،string ،bool } و غیره). این امر یا با تعیین نوع، هنگامی که متغیر اعلام می‌شود حاصل می شود یا در بسیاری از موارد، اجازه داده‌می‌شود که کامپایلر نوع را استنباط کند (به زودی به مثال‌ها خواهیم پرداخت).

در مورد  نوع داده ایستا چیزهای زیادی می توان گفت، اما من معتقدم که این با دیدن کد بهتر درک می‌شود. اگر شما به نوع داده پویا در زبان‌ها عادت دارید، ممکن است با مشکل روبرو شوید. شما اشتباه نمی‌کنید، اما مزایایی وجود دارد، به ویژه هنگامی که نوع داده ایستا را  با کامپایل باهم در نظر داشته باشید. این دو بیشتر مواقع باهم تلفیق می‌شوند. درست است که وقتی یکی را داشته باشید، معمولاً دیگری را نیز دارید اما این یک قانون همیشگی نیست. با استفاده از یک سیستم نوع  داده سفت و محکم وجود داشته‌باشد، کامپایلر قادر است مشکلات فراتر از اشتباهات صرفی را تشخیص دهد و همچنین بهینه‌سازی‌های بیشتری نیز انجام دهد.
\newpage
\section{ نحو \lr{C} مانند}
گفتن اینکه یک زبان دارای نحوی \lr{C} مانند است، به این معنی است که اگر شما به هر زبان \lr{C} مانند، نظیر 
\LRE{C ،C ++ ،Java ،JavaScript}
 و \lr{C\#} آشنا باشید، با \lr{Go} غریبه نخواهید بود- حداقل به صورت سطحی. به عنوان مثال، \verb*|&&| به عنوان boolean AND استفاده می‌شود، \verb*|==| برای مقایسه برابری،
 \lr{\{}
جهت شروع و
 \lr{\}}
 برای پایان یک دامنه به‌کار گرفته می‌شود و شاخص‌ آرایه از 0 شروع می‌شود.
 
 نحو \lr{C} مانند نیز به معنی خط‌های  پایان یافته با کاراکتر \lr{;} و پرانتزهای اطراف شرط‌ها است. \lr{Go} از هر دو مورد بی‌نیاز است، اگرچه هنوز از پرانتز برای کنترل تقدم عملیات استفاده می‌شود.
 به عنوان مثال ، دستور \verb*|if| به این شکل است:
 
 \begin{latin}
 	\begin{lstlisting}[language=Go]
 		if name == "Leto" {
 			print("the spice must flow")
 		}
 	\end{lstlisting}
 \end{latin}
و در موارد پیچیده‌تر، پرانتزها هنوز هم مفید هستند:

\begin{latin}
	\begin{lstlisting}[language=Go]
		if (name == "Goku" && power > 9000) || (name == "gohan" && power < 4000)
		{
			print("super Saiyan")
		}
	\end{lstlisting}
\end{latin}

فراتر از این، Go بسیار نزدیکتر  به \lr{C} است تا \lr{C\#} یا \lr{Java}- نه تنها از نظر نحو، بلکه از نظر هدف نیز این‌چنین است. این
در سختی و سادگی زبان منعکس شده است که امیدوارم همراه با یادگیری آن کاملاً مشهود شود.
\newpage
\section{زباله‌روب
\footnote{Garbage Collected}}
برخی از متغیرها، هنگام ایجاد، یک روش آسان برای تعریف دارند. به عنوان مثال، یک  متغیر محلی برای یک تابع، وقتی از بین می‌رود
که از تابع خارج شویم. در موارد دیگر، چندان واضح نیست - حداقل برای یک کامپایلر. به عنوان مثال، تعیین طول عمر یک متغیر که توسط یک تابع برگردانده می‌شود یا توسط متغیرها و اشیا دیگر به آن ارجاع می شود، مشکل است. بدون جمع آوری زباله، توسعه‌دهندگان وظیفه دارند حافظه مرتبط با چنین متغیرهایی را در نقطه‌ای که توسعه‌دهنده می‌داند دیگر به متغیر مورد نظر نیاز نیست، آزاد کنند. چگونه؟ در \lr{C} شما باید از
\verb*|free(str);|
برای آزادسازی حافظه استفاده کنید.

زبان‌هایی که دارای زباله‌روب هستند (به عنوان مثال، روبی، پایتون، جاوا، جاوا اسکریپت، سی شارپ، \lr{Go}) قادر به پیگیری این موارد هستند
و وقتی دیگر از متغیری استفاده نمی‌شود آن را آزاد می‌کنند. استفاده از زباله‌روب سربار اضافه می‌کند، اما در عوض تعدادی از اشکالات ویرانگر را از بین می‌برد.
\newpage
\section{اجرای کد \lr{Go}}
بیایید سفر خود را با ایجاد یک برنامه ساده و یادگیری نحوه کامپایل و اجرای آن آغاز کنیم. ویرایشگر متن مورد علاقه خود را باز کرده و کد زیر را بنویسید:
\begin{latin}
	\begin{lstlisting}[language=Go]
	package main
	func main() {
		println("it's over 9000!")
	}
	\end{lstlisting}
\end{latin}

فایل را به عنوان \LRE{\verb*|main.go|} ذخیره کنید. در حال حاضر، می توانید آن را در هر کجا که می‌خواهید ذخیره کنید. برای نمونه‌های بی‌اهمیت نیازی به کار در فضای کاری \lr{Go} نداریم.

سپس ،یک پوسته یا خط فرمان باز کرده و مسیر را به محلی که فایل را ذخیره کرده‌اید تغییر دهید. برای من، این به معنای تایپ  
\LRE{ \verb*|cd ~/code| }
است.


در آخر ،برنامه را با وارد دستور ذیل اجرا کنید:
\begin{latin}
	\begin{lstlisting}[language=bash]
		go run main.go
	\end{lstlisting}
\end{latin}

اگر همه چیز کار کرد، شما باید عبارت  \lr{it’s over 9000! } را ببینید.

اما صبر کنید ، در مورد مرحله کامپایل چه می‌کنید؟ \lr{go run} یک دستور مفید است که کد شما را کامپایل و اجرا می‌کند. برای ساخت برنامه از یک فهرست موقتی استفاده می‌کند، آن‌را اجرا و سپس خود را تمیز می‌کند. با اجرای دستور زیر می‌توانید مکان فایل موقت را مشاهده کنید:
\begin{latin}
	\begin{lstlisting}[language=bash]
		go run --work main.go
	\end{lstlisting}
\end{latin}

برای صرفاً کامپایل کردن کد، از دستور  \LRE{go build} استفاده کنید:
\begin{latin}
	\begin{lstlisting}[language=bash]
		go build main.go
	\end{lstlisting}
\end{latin}
این یک \lr{main} قابل اجرا ایجاد می‌کند که می‌توانید آن‌را اجرا کنید. در \lr{Linux / OSX} فراموش نکنید که باید فایل اجرایی را با پیشوند \verb*|./| تایپ کنید، بنابراین برای اجرا باید دستور \verb*|./main|  را تایپ کنید.

هنگام توسعه، می توانید از \LRE{go run} یا \LRE{go build} استفاده کنید. با این وجود، هنگامی که کد خود را پیاده‌سازی می‌کنید، می‌توانید یک باینری از طریق \LRE{go build} ایجاد کرده و آن را اجرا کنید.
\subsection{Main}
امیدوارم، کدی که ما تازه اجرا کردیم قابل درک باشد. ما یک تابع ایجاد کردیم و یک رشته را با تابع \verb*|println| داخلی چاپ کردیم. آیا  \LRE{go run} می‌دانست چه چیزی را اجرا کند با اینکه فقط یک انتخاب وجود داشت؟ خیر. در \lr{Go}، نقطه ورود به یک برنامه باید تابعی باشد به نام \lr{main} در یک بسته  \lr{main}.

در فصل بعدی درباره بسته‌ها بیشتر صحبت خواهیم کرد. در حال حاضر، در حالی که ما به درک اصول \lr{Go} توجه داریم، همیشه کد خود را در بسته \lr{main} می‌نویسیم.

در صورت تمایل می‌توانید کد را تغییر و نام بسته را تغییر دهید. کد را از طریق \LRE{go run} اجرا کنید و باید یک خطا دریافت کنید. سپس، نام را به \lr{main} تغییر دهید اما از نام تابع دیگری استفاده کنید. در این حالت باید یک پیام خطایی متفاوت ببینید. سعی کنید همان تغییرات را اعمال کنید اما به جای آن از \LRE{go build} استفاده کنید. توجه داشته باشید که کد کامپایل می‌شود، فقط نقطه ورودی برای اجرای آن وجود ندارد.
\newpage
\section{فراخوانی بسته‌ها
\footnote{\lr{Impots}}}

\lr{Go }
دارای تعدادی توابع داخلی مانند \verb*|println| است که بدون مرجعی قابل استفاده هستند. بدون استفاده از کتابخانه استاندارد \lr{Go} و در نهایت استفاده از کتابخانه‌های شخص ثالث\footnote{third-party}، نمی توانیم خیلی کارها را انجام دهیم. کلمه کلیدی \lr{import} برای شناساندن بسته‌های استفاده شده توسط کد موجود در فایل برنامه‌تان استفاده می‌شود.

بیایید برنامه خود را به شکل زیر تغییر دهیم:
\begin{latin}
	\begin{lstlisting}[language=Go]
		package main
		
		import (
		"fmt"
		"os"
		)
		func main() {
			if len(os.Args) != 2 {
				os.Exit(1)
			}
			fmt.Println("It's over", os.Args[1])
		}
	\end{lstlisting}
\end{latin}
که می توانید از طریق دستور زیر آن‌را اجرا کنید:
\begin{latin}
	\begin{lstlisting}[language=bash]
		go run main.go 9000
	\end{lstlisting}
\end{latin}
همانگونه که مشاهده می‌کنید  ما از دو بسته استاندارد \lr{Go} استفاده می کنیم یعنی: \verb*|fmt| و \verb*|os|. ما همچنین یکی دیگر از توابع داخلی یعنی \verb*|len| را معرفی کرده‌ایم. \verb*|len| اندازه یک رشته یا تعداد مقادیر دیکشنری یا همانطور که در اینجا می‌بینیم تعداد عناصر آرایه را برمی‌گرداند. اگر از خود می‌پرسید که چرا ما انتظار داریم ۲ آرگومان داشته باشیم، دلیل آن این است که اولین آرگومان - در شاخص 0 - همیشه مسیر اجرایی در حال اجرا است. (برنامه را تغییر دهید تا چاپ شود و خودتان ببینید.).

احتمالاً متوجه شده‌اید که پیشوند نام تابع را با نام بسته به‌کار می‌بریم، به عنوان مثال، \verb*|fmt.Println|. این با بسیاری از زبان‌های دیگر متفاوت است. در فصل‌های بعدی درباره بسته‌ها بیشتر خواهیم آموخت. در حال حاضر، دانستن نحوه وارد کردن و استفاده از بسته‌ها، شروع خوبی است.

\lr{Go}
در مورد فراخوانی بسته‌ها سخت‌گیری می‌کند. اگر بسته‌ای را وارد کنید اما از آن استفاده نکنید، کامپایل نمی‌شود. سعی کنید موارد زیر را اجرا کنید.

\begin{latin}
	\begin{lstlisting}[language=Go]
		package main
		
		import (
		"fmt"
		"os"
		)
		func main() {
		}
	\end{lstlisting}
\end{latin}
برای \verb*|fmt| و \verb*|os| که فراخوانی شده‌اند ولی استفاده نشده‌اند باید دو خطا دریافت کنید. آیا این می‌تواند آزار دهنده باشد؟ در  پاسخ باید گفت، کاملاً  آزار دهنده است. با گذشت زمان، شما به آن عادت خواهید کرد (هر چند هنوز آزار دهنده خواهد بود).
رفتار  \lr{Go}
 در این مورد سختگیرانه است زیرا فراخوانیِ بلااستفاده می‌تواند کامپایل را کند کند. مسلماً مشکلی که اکثر ما تا این حد با آن روبرو نیستیم. 
 
 نکته دیگری که باید به آن توجه کنید این است که کتابخانه استاندارد \lr{Go} به خوبی و به طور کامل مستند شده‌است. به طور مثال برای کسب اطلاعات بیشتر در مورد تابع \lr{Println} که ما استفاده کردیم می‌توانید به \url{https://golang.org/pkg/fmt/#Println} مراجعه کنید. می‌توانید بر روی عنوان آن قسمت کلیک کرده و کد منبع را مشاهده کنید. همچنین، برای کسب اطلاعات بیشتر در مورد قابلیت‌های قالب‌بندی \lr{Go}، به بالا بروید.
 
اگر در جایی بدون دسترسی به اینترنت گیر کرده‌اید، می توانید مستندات را به صورت محلی از طریق زیر دریافت کنید:
\begin{latin}
	\begin{lstlisting}[language=bash]
	godoc -http=:6060
	\end{lstlisting}
\end{latin}
و  در مرورگر خود آدرس  \url{http://localhost:6060} را وارد کنید.
 
\newpage
\section{متغیرها و اعلان‌ها}

\newpage
\section{توابع و اعلان‌ها}

\newpage
\section{قبل از ادامه}
\chapter{ ساختارها }
\chapter{ نقشه‌ها، آرایه‌ها و برش‌ها }
\chapter{ساختار کد و رابط‌ها }
\chapter{ریزه‌کاری‌ها }
\chapter{همزمانی}
\chapter{نتیجه‌گیری}
\end{document}‎
